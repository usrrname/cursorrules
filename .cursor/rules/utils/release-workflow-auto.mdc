---
description: This rule prepares for a package release through a series of user preferences: creating a release branch, generate release notes, creating or updating the changelog.md file, and updating the package.json version. It analyzes the git diff between the previous tag and the latest commit, and provides version bumping options based on semantic versioning.
globs: release-notes-*.md, changelog.md
alwaysApply: false
---
# Release Workflow

## Critical Rules

- Must only trigger when user asks to create a release (release, version, tag, etc.)
- Must check that user is NOT on main/master branch before proceeding
- Must warn user if they're on main branch and suggest creating a release branch
- Must identify the most recent git tag as the baseline for comparison
- Must analyze commit messages, file changes, and code modifications
- Must categorize changes into Features, Bug Fixes, Breaking Changes, and Other
- Must provide a structured summary suitable for release documentation
- Must handle cases where no previous tags exist
- Must exclude merge commits and focus on meaningful changes
- Must link features and changes to their corresponding commits or PRs
- Must provide version bumping options (major, minor, patch) based on semantic versioning
- Must suggest appropriate version bump based on change analysis
- Must automatically generate or update changelog.md after creating release notes
- Must ensure changelog follows Keep a Changelog format standards
- Must include unreleased changes section in changelog
- Must offer to create a git tag for the new version
- Must offer to automatically update package.json version property
- Must offer to commit version changes with appropriate commit message
- Must provide clear confirmation prompts before making changes
- Must update release-workflow-sequence.md to reflect any changes to this workflow rule
- Must ensure sequence diagram accurately represents current workflow implementation and failure points

<rule>
name: release-workflow-auto

filters:
- type: content
    pattern: "(release|version|tag|bump|publish|deploy).*(create|make|generate|prepare|ready)"
  - type: git_branch
    pattern: "^(?!main$|master$).*$"
  - type: event
    pattern: "chat_start|chat_response"

actions:
  - type: validate
    conditions:
      - pattern: "^(main|master)$"
        message: "‚ö†Ô∏è You're currently on the main branch! Please create a release branch before generating release notes. This ensures proper version control and prevents accidental releases."
  
  - type: generate
    content: |

    ## üöÄ Release Workflow Process
      
      I'll help you create comprehensive release notes, update the changelog, and handle version bumping! Let me analyze your changes and guide you through the entire release process.
      
      1. **Branch Validation** ‚úÖ
         ```bash
         # Check current branch
         CURRENT_BRANCH=$(git branch --show-current)
         echo "Current branch: $CURRENT_BRANCH"
         
         # Verify we're not on main/master
         if [[ "$CURRENT_BRANCH" == "main" || "$CURRENT_BRANCH" == "master" ]]; then
           echo "‚ùå Error: Cannot generate release notes on main/master branch"
           echo "Please create a release branch first:"
           echo "git checkout -b release/v[VERSION]"
           exit 1
         fi
         
         # Validate branch naming conventions
         echo "üîç Validating branch naming conventions..."
         
         # Only allow releases from branches that start with "release/", "hotfix/", or "fix/"
         if [[ ! "$CURRENT_BRANCH" =~ ^(release|hotfix|fix)/ ]]; then
           echo "‚ùå ERROR: Releases can only be created from branches that start with 'release/', 'hotfix/', or 'fix/'"
           echo ""
           echo "Current branch: $CURRENT_BRANCH"
           echo ""
           echo "Please create an appropriate branch first:"
           echo "git checkout -b release/v[VERSION]"
           echo "git checkout -b hotfix/urgent-fix-v[VERSION]"
           echo "git checkout -b fix/bug-description-v[VERSION]"
           echo ""
           echo "Examples of valid release branches:"
           echo "- release/v1.2.3"
           echo "- release/v2.0.0"
           echo "- hotfix/security-patch-v1.2.4"
           echo "- fix/memory-leak-v1.1.5"
           echo "- release/feature-name-v1.1.0"
           echo ""
           echo "‚ùå Release workflow terminated due to invalid branch"
           exit 1
         fi
         
         echo "‚úÖ Branch validation passed - using $CURRENT_BRANCH"
         ```
      
      2. **Identify Current Version**:
         ```bash
         # Validate package.json exists and is valid
         if [ ! -f "package.json" ]; then
           echo "‚ùå ERROR: package.json not found in current directory"
           echo "Please ensure you're running this workflow from the project root directory"
           echo "Current directory: $(pwd)"
           exit 1
         fi
         
         # Validate package.json is valid JSON
         if ! node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf8'))" 2>/dev/null; then
           echo "‚ùå ERROR: package.json contains invalid JSON"
           echo "Please fix the JSON syntax in package.json before proceeding"
           exit 1
         fi
         
         # Validate required fields exist
         REQUIRED_FIELDS=("name" "version")
         for field in "${REQUIRED_FIELDS[@]}"; do
           if ! node -e "const pkg = require('./package.json'); if (!pkg.$field) { process.exit(1); }" 2>/dev/null; then
             echo "‚ùå ERROR: package.json is missing required field: $field"
             echo "Please add the '$field' field to package.json before proceeding"
             exit 1
           fi
         done
         
         # Validate version format (semantic versioning)
         VERSION_REGEX="^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$"
         CURRENT_VERSION=$(node -p "require('./package.json').version")
         
         if [[ ! "$CURRENT_VERSION" =~ $VERSION_REGEX ]]; then
           echo "‚ùå ERROR: Invalid version format in package.json: $CURRENT_VERSION"
           echo "Version must follow semantic versioning format: x.y.z[-prerelease][+build]"
           echo "Examples: 1.2.3, 2.0.0-beta.1, 1.0.0+20231201"
           exit 1
         fi
         
         # Read current version from package.json
         echo "‚úÖ Package.json validation passed"
         echo "Package name: $(node -p "require('./package.json').name")"
         echo "Current version: $CURRENT_VERSION"
         
         # Get the most recent git tag (if exists)
         LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v$CURRENT_VERSION")
         
         echo "Latest git tag: $LATEST_TAG"
         ```
      
      3. **Check User Request for Version Bump**:
         ```bash
         # Check if user specified version bump in their request
         if [[ "$USER_REQUEST" == *"major"* ]] || [[ "$USER_REQUEST" == *"Major"* ]]; then
           VERSION_BUMP="major"
           echo "User requested major version bump"
         elif [[ "$USER_REQUEST" == *"minor"* ]] || [[ "$USER_REQUEST" == *"Minor"* ]]; then
           VERSION_BUMP="minor"
           echo "User requested minor version bump"
         elif [[ "$USER_REQUEST" == *"patch"* ]] || [[ "$USER_REQUEST" == *"Patch"* ]]; then
           VERSION_BUMP="patch"
           echo "User requested patch version bump"
         else
           VERSION_BUMP=""
           echo "No version bump specified by user"
         fi
         ```
      
      4. **Analyze Changes for Guidance**:
         ```bash
         # Get all commits since that tag with full details
         COMMITS=$(git log --oneline --no-merges $LATEST_TAG..HEAD)
         
         # Get detailed commit information for better analysis
         COMMIT_DETAILS=$(git log --format="%H%n%s%n%b" --no-merges $LATEST_TAG..HEAD)
         
         # Analyze conventional commit types for version bump suggestion
         BREAKING_COUNT=$(echo "$COMMITS" | grep -c "BREAKING:" || echo "0")
         FEAT_COUNT=$(echo "$COMMITS" | grep -c "feat:" || echo "0")
         FIX_COUNT=$(echo "$COMMITS" | grep -c "fix:" || echo "0")
         DOCS_COUNT=$(echo "$COMMITS" | grep -c "docs:" || echo "0")
         STYLE_COUNT=$(echo "$COMMITS" | grep -c "style:" || echo "0")
         REFACTOR_COUNT=$(echo "$COMMITS" | grep -c "refactor:" || echo "0")
         PERF_COUNT=$(echo "$COMMITS" | grep -c "perf:" || echo "0")
         TEST_COUNT=$(echo "$COMMITS" | grep -c "test:" || echo "0")
         CHORE_COUNT=$(echo "$COMMITS" | grep -c "chore:" || echo "0")
         
         # Analyze non-conventional commits with intelligent categorization
         NON_CONVENTIONAL_COMMITS=$(echo "$COMMITS" | grep -v "^(feat|fix|docs|style|refactor|perf|test|chore):" | grep -v "BREAKING:")
         
         if [ -n "$NON_CONVENTIONAL_COMMITS" ]; then
           echo "üîç Found non-conventional commits, analyzing content for categorization..."
           
           # Initialize counters for non-conventional commits
           NC_FEAT_COUNT=0
           NC_FIX_COUNT=0
           NC_BREAKING_COUNT=0
           NC_DOCS_COUNT=0
           NC_OTHER_COUNT=0
           
           # Analyze each non-conventional commit
           while IFS= read -r commit; do
             HASH=$(echo "$commit" | cut -d' ' -f1)
             MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
             
             # Get files changed in this commit
             FILES_CHANGED=$(git show --name-only --format="" "$HASH" 2>/dev/null)
             
             # Categorize based on message content and file changes
             if [[ "$MESSAGE" =~ (add|new|implement|create|introduce|support|enable|feature) ]]; then
               NC_FEAT_COUNT=$((NC_FEAT_COUNT + 1))
               echo "  üìù Non-conventional commit categorized as FEATURE: $MESSAGE"
             elif [[ "$MESSAGE" =~ (fix|bug|issue|problem|error|crash|fail|broken|resolve|correct) ]]; then
               NC_FIX_COUNT=$((NC_FIX_COUNT + 1))
               echo "  üêõ Non-conventional commit categorized as FIX: $MESSAGE"
             elif [[ "$MESSAGE" =~ (BREAKING|breaking|remove|delete|drop|deprecate|change|update|upgrade|migrate) ]]; then
               NC_BREAKING_COUNT=$((NC_BREAKING_COUNT + 1))
               echo "  üí• Non-conventional commit categorized as BREAKING: $MESSAGE"
             elif [[ "$MESSAGE" =~ (doc|readme|comment|example|guide|tutorial) ]] || echo "$FILES_CHANGED" | grep -q "\.md$\|\.txt$\|docs/\|README"; then
               NC_DOCS_COUNT=$((NC_DOCS_COUNT + 1))
               echo "  üìö Non-conventional commit categorized as DOCS: $MESSAGE"
             else
               NC_OTHER_COUNT=$((NC_OTHER_COUNT + 1))
               echo "  üîß Non-conventional commit categorized as OTHER: $MESSAGE"
             fi
           done <<< "$NON_CONVENTIONAL_COMMITS"
           
           # Add non-conventional counts to conventional counts
           FEAT_COUNT=$((FEAT_COUNT + NC_FEAT_COUNT))
           FIX_COUNT=$((FIX_COUNT + NC_FIX_COUNT))
           BREAKING_COUNT=$((BREAKING_COUNT + NC_BREAKING_COUNT))
           DOCS_COUNT=$((DOCS_COUNT + NC_DOCS_COUNT))
           
           echo "üìä Non-conventional commit analysis complete:"
           echo "  - Features: $NC_FEAT_COUNT"
           echo "  - Fixes: $NC_FIX_COUNT"
           echo "  - Breaking: $NC_BREAKING_COUNT"
           echo "  - Docs: $NC_DOCS_COUNT"
           echo "  - Other: $NC_OTHER_COUNT"
         fi
         
         # Determine version bump suggestion based on all analyzed commits
         if [ "$BREAKING_COUNT" -gt 0 ]; then
           SUGGESTED_BUMP="major"
         elif [ "$FEAT_COUNT" -gt 0 ]; then
           SUGGESTED_BUMP="minor"
         elif [ "$FIX_COUNT" -gt 0 ]; then
           SUGGESTED_BUMP="patch"
         else
           SUGGESTED_BUMP="patch"
         fi
         
         echo "üìà Commit analysis summary:"
         echo "  - Breaking changes: $BREAKING_COUNT"
         echo "  - New features: $FEAT_COUNT"
         echo "  - Bug fixes: $FIX_COUNT"
         echo "  - Documentation: $DOCS_COUNT"
         echo "  - Style/Refactor: $((STYLE_COUNT + REFACTOR_COUNT))"
         echo "  - Performance: $PERF_COUNT"
         echo "  - Tests: $TEST_COUNT"
         echo "  - Chores: $CHORE_COUNT"
         echo "  - Suggested version bump: $SUGGESTED_BUMP"
         ```
      
      5. **Prompt User for Version Bump (if not specified)**:
         ```bash
         if [ -z "$VERSION_BUMP" ]; then
           # Calculate potential new versions
           MAJOR_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1+1 ".0.0"}')
           MINOR_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1 "." $2+1 ".0"}')
           PATCH_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1 "." $2 "." $3+1}')
           
           echo "Choose your version bump:"
           echo "1) Major version: $CURRENT_VERSION ‚Üí $MAJOR_VERSION (breaking changes)"
           echo "2) Minor version: $CURRENT_VERSION ‚Üí $MINOR_VERSION (new features)"
           echo "3) Patch version: $CURRENT_VERSION ‚Üí $PATCH_VERSION (bug fixes)"
           echo "4) Custom version"
           
           # Wait for user input
           read -p "Enter your choice (1-4): " USER_CHOICE
           
           case $USER_CHOICE in
             1) VERSION_BUMP="major" ;;
             2) VERSION_BUMP="minor" ;;
             3) VERSION_BUMP="patch" ;;
             4) 
               read -p "Enter custom version: " CUSTOM_VERSION
               VERSION_BUMP="custom"
               ;;
           esac
         fi
         ```
      
      5.5. **Validate Version Bump Against Changes**:
         ```bash
         # Validate that the chosen version bump matches the change analysis
         if [ -n "$VERSION_BUMP" ]; then
           echo "üîç Validating version bump against change analysis..."
           echo "Analysis suggests: $SUGGESTED_BUMP (breaking: $BREAKING_COUNT, features: $FEAT_COUNT, fixes: $FIX_COUNT)"
           echo "User requested: $VERSION_BUMP"
           
           # Check for version mismatches
           if [ "$SUGGESTED_BUMP" == "major" ] && [ "$VERSION_BUMP" != "major" ]; then
             echo "‚ùå CRITICAL ERROR: Breaking changes detected but user requested $VERSION_BUMP version"
             echo "Breaking changes require a MAJOR version bump according to semantic versioning."
             echo ""
             echo "Breaking changes found:"
             echo "$COMMITS" | grep "BREAKING:" | while read commit; do
               echo "  - $commit"
             done
             echo ""
             echo "Please either:"
             echo "1. Use major version bump to properly indicate breaking changes"
             echo "2. Review and remove breaking changes from your commits"
             echo "3. Use '--force' flag to override this validation (not recommended)"
             echo ""
             read -p "Do you want to force continue with $VERSION_BUMP version? (y/N): " FORCE_CONTINUE
             if [[ ! "$FORCE_CONTINUE" =~ ^[Yy]$ ]]; then
               echo "‚ùå Release workflow terminated due to version mismatch"
               exit 1
             else
               echo "‚ö†Ô∏è WARNING: Proceeding with $VERSION_BUMP version despite breaking changes"
               echo "This may cause dependency issues for users of your package"
             fi
           elif [ "$SUGGESTED_BUMP" == "minor" ] && [ "$VERSION_BUMP" == "patch" ]; then
             echo "‚ö†Ô∏è WARNING: New features detected but user requested patch version"
             echo "New features typically require a MINOR version bump according to semantic versioning."
             echo ""
             echo "New features found:"
             echo "$COMMITS" | grep "feat:" | while read commit; do
               echo "  - $commit"
             done
             echo ""
             read -p "Do you want to continue with patch version? (y/N): " CONTINUE_PATCH
             if [[ ! "$CONTINUE_PATCH" =~ ^[Yy]$ ]]; then
               echo "‚ùå Release workflow terminated due to version mismatch"
               exit 1
             else
               echo "‚ö†Ô∏è WARNING: Proceeding with patch version despite new features"
             fi
           else
             echo "‚úÖ Version bump validation passed"
           fi
         fi
         ```
      6. **Generate Structured Release Notes**:
         ```bash
         $RELEASE_DATE=$(date +%Y-%m-%d)
         ```
         ```markdown
         # What's Changed in [PACKAGE_NAME] v[NEW_VERSION]
         
         **Release Date**: [RELEASE_DATE]
         **Previous Version**: [PREVIOUS_VERSION]
         **Version Bump**: [MAJOR|MINOR|PATCH] - [REASON]
         **Branch**: [CURRENT_BRANCH]
         
         ## üöÄ New Features
         - **[Feature Name]** ([commit-hash](link-to-commit)) - [Description]
         - **[Feature Name]** ([#PR-number](link-to-PR)) - [Description]
         
         ## üêõ Bug Fixes  
         - **[Bug Description]** ([commit-hash](link-to-commit)) - [Fix details]
         - **[Bug Description]** ([#PR-number](link-to-PR)) - [Fix details]
         
         ## üí• Breaking Changes
         - **[Change Description]** ([commit-hash](link-to-commit)) - [Migration notes]
         - **[Change Description]** ([#PR-number](link-to-PR)) - [Migration notes]
         
         ## üìö Documentation
         - **[Doc Update]** ([commit-hash](link-to-commit)) - [Description]
         - **[Doc Update]** ([#PR-number](link-to-PR)) - [Description]
         
         ## üîß Other Changes
         - **[Change Description]** ([commit-hash](link-to-commit)) - [Details]
         - **[Change Description]** ([#PR-number](link-to-PR)) - [Details]
      
      7. **Generate Changelog** üìù
         ```bash
         echo "üîÑ Now generating comprehensive changelog..."
         
         # Backup existing changelog if it exists
         if [ -f "changelog.md" ]; then
           cp changelog.md changelog.md.backup
           echo "üìã Backed up existing changelog.md"
           
           # Check if existing changelog has proper structure
           if grep -q "## \[Unreleased\]" changelog.md; then
             echo "‚úÖ Existing changelog has proper structure, will preserve content"
             PRESERVE_EXISTING=true
           else
             echo "‚ö†Ô∏è Existing changelog doesn't follow Keep a Changelog format"
             echo "Will create new changelog with existing content as reference"
             PRESERVE_EXISTING=false
           fi
         else
           echo "üìù No existing changelog.md found, creating new one"
           PRESERVE_EXISTING=false
         fi
         
         # Get all git tags sorted by version
         ALL_TAGS=$(git tag --sort=-version:refname)
         
         # Get commits since last tag (unreleased changes)
         UNRELEASED_COMMITS=$(git log --oneline --no-merges $(git describe --tags --abbrev=0 2>/dev/null || echo "")..HEAD)
         
         if [ "$PRESERVE_EXISTING" = true ]; then
           echo "üîÑ Updating existing changelog with new unreleased changes..."
           
           # Create temporary file for new unreleased content
           TEMP_UNRELEASED=$(mktemp)
           
           # Process conventional commits
           CONVENTIONAL_FEATURES=$(echo "$UNRELEASED_COMMITS" | grep "feat:")
           CONVENTIONAL_FIXES=$(echo "$UNRELEASED_COMMITS" | grep "fix:")
           CONVENTIONAL_BREAKING=$(echo "$UNRELEASED_COMMITS" | grep "BREAKING:")
           CONVENTIONAL_DOCS=$(echo "$UNRELEASED_COMMITS" | grep "docs:")
           
           # Process non-conventional commits
           NON_CONVENTIONAL_COMMITS=$(echo "$UNRELEASED_COMMITS" | grep -v "^(feat|fix|docs|style|refactor|perf|test|chore):" | grep -v "BREAKING:")
           
           # Categorize non-conventional commits
           NC_FEATURES=""
           NC_FIXES=""
           NC_BREAKING=""
           NC_DOCS=""
           NC_OTHER=""
           
           if [ -n "$NON_CONVENTIONAL_COMMITS" ]; then
             echo "üîç Categorizing non-conventional commits for changelog..."
             
             while IFS= read -r commit; do
               HASH=$(echo "$commit" | cut -d' ' -f1)
               MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
               
               # Get files changed in this commit
               FILES_CHANGED=$(git show --name-only --format="" "$HASH" 2>/dev/null)
               
               # Categorize based on message content and file changes
               if [[ "$MESSAGE" =~ (add|new|implement|create|introduce|support|enable|feature) ]]; then
                 NC_FEATURES="$NC_FEATURES$commit"$'\n'
               elif [[ "$MESSAGE" =~ (fix|bug|issue|problem|error|crash|fail|broken|resolve|correct) ]]; then
                 NC_FIXES="$NC_FIXES$commit"$'\n'
               elif [[ "$MESSAGE" =~ (BREAKING|breaking|remove|delete|drop|deprecate|change|update|upgrade|migrate) ]]; then
                 NC_BREAKING="$NC_BREAKING$commit"$'\n'
               elif [[ "$MESSAGE" =~ (doc|readme|comment|example|guide|tutorial) ]] || echo "$FILES_CHANGED" | grep -q "\.md$\|\.txt$\|docs/\|README"; then
                 NC_DOCS="$NC_DOCS$commit"$'\n'
               else
                 NC_OTHER="$NC_OTHER$commit"$'\n'
               fi
             done <<< "$NON_CONVENTIONAL_COMMITS"
           fi
           
           # Combine conventional and non-conventional commits
           ALL_FEATURES="$CONVENTIONAL_FEATURES$NC_FEATURES"
           ALL_FIXES="$CONVENTIONAL_FIXES$NC_FIXES"
           ALL_BREAKING="$CONVENTIONAL_BREAKING$NC_BREAKING"
           ALL_DOCS="$CONVENTIONAL_DOCS$NC_DOCS"
           
           # Generate new unreleased content
           if [ -n "$ALL_FEATURES" ]; then
             echo "### üöÄ Added" >> "$TEMP_UNRELEASED"
             echo "$ALL_FEATURES" | while read commit; do
               if [ -n "$commit" ]; then
                 HASH=$(echo $commit | cut -d' ' -f1)
                 MESSAGE=$(echo $commit | cut -d' ' -f2-)
                 echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> "$TEMP_UNRELEASED"
               fi
             done
             echo "" >> "$TEMP_UNRELEASED"
           fi
           
           if [ -n "$ALL_FIXES" ]; then
             echo "### üêõ Fixed" >> "$TEMP_UNRELEASED"
             echo "$ALL_FIXES" | while read commit; do
               if [ -n "$commit" ]; then
                 HASH=$(echo $commit | cut -d' ' -f1)
                 MESSAGE=$(echo $commit | cut -d' ' -f2-)
                 echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> "$TEMP_UNRELEASED"
               fi
             done
             echo "" >> "$TEMP_UNRELEASED"
           fi
           
           if [ -n "$ALL_BREAKING" ]; then
             echo "### üí• Changed" >> "$TEMP_UNRELEASED"
             echo "$ALL_BREAKING" | while read commit; do
               if [ -n "$commit" ]; then
                 HASH=$(echo $commit | cut -d' ' -f1)
                 MESSAGE=$(echo $commit | cut -d' ' -f2-)
                 echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> "$TEMP_UNRELEASED"
               fi
             done
             echo "" >> "$TEMP_UNRELEASED"
           fi
           
           if [ -n "$ALL_DOCS" ]; then
             echo "### üìö Documentation" >> "$TEMP_UNRELEASED"
             echo "$ALL_DOCS" | while read commit; do
               if [ -n "$commit" ]; then
                 HASH=$(echo $commit | cut -d' ' -f1)
                 MESSAGE=$(echo $commit | cut -d' ' -f2-)
                 echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> "$TEMP_UNRELEASED"
               fi
             done
             echo "" >> "$TEMP_UNRELEASED"
           fi
           
           if [ -n "$NC_OTHER" ]; then
             echo "### üîß Other Changes" >> "$TEMP_UNRELEASED"
             echo "$NC_OTHER" | while read commit; do
               if [ -n "$commit" ]; then
                 HASH=$(echo $commit | cut -d' ' -f1)
                 MESSAGE=$(echo $commit | cut -d' ' -f2-)
                 echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> "$TEMP_UNRELEASED"
               fi
             done
             echo "" >> "$TEMP_UNRELEASED"
           fi
           
           # Replace the [Unreleased] section with new content
           awk -v temp="$TEMP_UNRELEASED" '
           /^## \[Unreleased\]/ {
             print "## [Unreleased]"
             print ""
             system("cat " temp)
             next
           }
           /^### üöÄ Added$/, /^## \[/ {
             if ($0 ~ /^## \[/) {
               print $0
               next
             }
             next
           }
           /^### üêõ Fixed$/, /^## \[/ {
             if ($0 ~ /^## \[/) {
               print $0
               next
             }
             next
           }
           /^### üí• Changed$/, /^## \[/ {
             if ($0 ~ /^## \[/) {
               print $0
               next
             }
             next
           }
           /^### üìö Documentation$/, /^## \[/ {
             if ($0 ~ /^## \[/) {
               print $0
               next
             }
             next
           }
           /^### üîß Other Changes$/, /^## \[/ {
             if ($0 ~ /^## \[/) {
               print $0
               next
             }
             next
           }
           { print }
           ' changelog.md > changelog.md.new
           
           mv changelog.md.new changelog.md
           rm -f "$TEMP_UNRELEASED"
           
           echo "‚úÖ Updated existing changelog with new unreleased changes"
         else
           echo "üîÑ Creating new changelog..."
           
           # Generate changelog content
           cat > changelog.md << 'EOF'
           # Changelog
           
           All notable changes to this project will be documented in this file.
           
           The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
           and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
           
           ## [Unreleased]
           
           EOF
           
           # Add unreleased changes if any
           if [ -n "$UNRELEASED_COMMITS" ]; then
             # Process conventional commits
             CONVENTIONAL_FEATURES=$(echo "$UNRELEASED_COMMITS" | grep "feat:")
             CONVENTIONAL_FIXES=$(echo "$UNRELEASED_COMMITS" | grep "fix:")
             CONVENTIONAL_BREAKING=$(echo "$UNRELEASED_COMMITS" | grep "BREAKING:")
             CONVENTIONAL_DOCS=$(echo "$UNRELEASED_COMMITS" | grep "docs:")
             
             # Process non-conventional commits
             NON_CONVENTIONAL_COMMITS=$(echo "$UNRELEASED_COMMITS" | grep -v "^(feat|fix|docs|style|refactor|perf|test|chore):" | grep -v "BREAKING:")
             
             # Categorize non-conventional commits
             NC_FEATURES=""
             NC_FIXES=""
             NC_BREAKING=""
             NC_DOCS=""
             NC_OTHER=""
             
             if [ -n "$NON_CONVENTIONAL_COMMITS" ]; then
               echo "üîç Categorizing non-conventional commits for changelog..."
               
               while IFS= read -r commit; do
                 HASH=$(echo "$commit" | cut -d' ' -f1)
                 MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                 
                 # Get files changed in this commit
                 FILES_CHANGED=$(git show --name-only --format="" "$HASH" 2>/dev/null)
                 
                 # Categorize based on message content and file changes
                 if [[ "$MESSAGE" =~ (add|new|implement|create|introduce|support|enable|feature) ]]; then
                   NC_FEATURES="$NC_FEATURES$commit"$'\n'
                 elif [[ "$MESSAGE" =~ (fix|bug|issue|problem|error|crash|fail|broken|resolve|correct) ]]; then
                   NC_FIXES="$NC_FIXES$commit"$'\n'
                 elif [[ "$MESSAGE" =~ (BREAKING|breaking|remove|delete|drop|deprecate|change|update|upgrade|migrate) ]]; then
                   NC_BREAKING="$NC_BREAKING$commit"$'\n'
                 elif [[ "$MESSAGE" =~ (doc|readme|comment|example|guide|tutorial) ]] || echo "$FILES_CHANGED" | grep -q "\.md$\|\.txt$\|docs/\|README"; then
                   NC_DOCS="$NC_DOCS$commit"$'\n'
                 else
                   NC_OTHER="$NC_OTHER$commit"$'\n'
                 fi
               done <<< "$NON_CONVENTIONAL_COMMITS"
             fi
             
             # Combine conventional and non-conventional commits
             ALL_FEATURES="$CONVENTIONAL_FEATURES$NC_FEATURES"
             ALL_FIXES="$CONVENTIONAL_FIXES$NC_FIXES"
             ALL_BREAKING="$CONVENTIONAL_BREAKING$NC_BREAKING"
             ALL_DOCS="$CONVENTIONAL_DOCS$NC_DOCS"
             
             # Write features section
             if [ -n "$ALL_FEATURES" ]; then
               echo "### üöÄ Added" >> changelog.md
               echo "$ALL_FEATURES" | while read commit; do
                 if [ -n "$commit" ]; then
                   HASH=$(echo $commit | cut -d' ' -f1)
                   MESSAGE=$(echo $commit | cut -d' ' -f2-)
                   echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                 fi
               done
               echo "" >> changelog.md
             fi
             
             # Write fixes section
             if [ -n "$ALL_FIXES" ]; then
               echo "### üêõ Fixed" >> changelog.md
               echo "$ALL_FIXES" | while read commit; do
                 if [ -n "$commit" ]; then
                   HASH=$(echo $commit | cut -d' ' -f1)
                   MESSAGE=$(echo $commit | cut -d' ' -f2-)
                   echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                 fi
               done
               echo "" >> changelog.md
             fi
             
             # Write breaking changes section
             if [ -n "$ALL_BREAKING" ]; then
               echo "### üí• Changed" >> changelog.md
               echo "$ALL_BREAKING" | while read commit; do
                 if [ -n "$commit" ]; then
                   HASH=$(echo $commit | cut -d' ' -f1)
                   MESSAGE=$(echo $commit | cut -d' ' -f2-)
                   echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                 fi
               done
               echo "" >> changelog.md
             fi
             
             # Write documentation section
             if [ -n "$ALL_DOCS" ]; then
               echo "### üìö Documentation" >> changelog.md
               echo "$ALL_DOCS" | while read commit; do
                 if [ -n "$commit" ]; then
                   HASH=$(echo $commit | cut -d' ' -f1)
                   MESSAGE=$(echo $commit | cut -d' ' -f2-)
                   echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                 fi
               done
               echo "" >> changelog.md
             fi
             
             # Write other changes section
             if [ -n "$NC_OTHER" ]; then
               echo "### üîß Other Changes" >> changelog.md
               echo "$NC_OTHER" | while read commit; do
                 if [ -n "$commit" ]; then
                   HASH=$(echo $commit | cut -d' ' -f1)
                   MESSAGE=$(echo $commit | cut -d' ' -f2-)
                   echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                 fi
               done
               echo "" >> changelog.md
             fi
           else
             echo "No unreleased changes." >> changelog.md
           fi
           
           echo "" >> changelog.md
           echo "---" >> changelog.md
           echo "" >> changelog.md
           
           # Add version entries for each tag
           for tag in $ALL_TAGS; do
             PREV_TAG=$(git describe --tags --abbrev=0 $tag^ 2>/dev/null || echo "")
             TAG_DATE=$(git log -1 --format=%cd --date=short $tag)
             
             echo "## [$tag] - $TAG_DATE" >> changelog.md
             echo "" >> changelog.md
             
             # Get commits for this version
             VERSION_COMMITS=$(git log --oneline --no-merges $PREV_TAG..$tag)
             
             if [ -n "$VERSION_COMMITS" ]; then
               # Process conventional commits for this version
               V_CONVENTIONAL_FEATURES=$(echo "$VERSION_COMMITS" | grep "feat:")
               V_CONVENTIONAL_FIXES=$(echo "$VERSION_COMMITS" | grep "fix:")
               V_CONVENTIONAL_BREAKING=$(echo "$VERSION_COMMITS" | grep "BREAKING:")
               V_CONVENTIONAL_DOCS=$(echo "$VERSION_COMMITS" | grep "docs:")
               
               # Process non-conventional commits for this version
               V_NON_CONVENTIONAL_COMMITS=$(echo "$VERSION_COMMITS" | grep -v "^(feat|fix|docs|style|refactor|perf|test|chore):" | grep -v "BREAKING:")
               
               # Categorize non-conventional commits for this version
               V_NC_FEATURES=""
               V_NC_FIXES=""
               V_NC_BREAKING=""
               V_NC_DOCS=""
               V_NC_OTHER=""
               
               if [ -n "$V_NON_CONVENTIONAL_COMMITS" ]; then
                 while IFS= read -r commit; do
                   HASH=$(echo "$commit" | cut -d' ' -f1)
                   MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                   
                   # Get files changed in this commit
                   FILES_CHANGED=$(git show --name-only --format="" "$HASH" 2>/dev/null)
                   
                   # Categorize based on message content and file changes
                   if [[ "$MESSAGE" =~ (add|new|implement|create|introduce|support|enable|feature) ]]; then
                     V_NC_FEATURES="$V_NC_FEATURES$commit"$'\n'
                   elif [[ "$MESSAGE" =~ (fix|bug|issue|problem|error|crash|fail|broken|resolve|correct) ]]; then
                     V_NC_FIXES="$V_NC_FIXES$commit"$'\n'
                   elif [[ "$MESSAGE" =~ (BREAKING|breaking|remove|delete|drop|deprecate|change|update|upgrade|migrate) ]]; then
                     V_NC_BREAKING="$V_NC_BREAKING$commit"$'\n'
                   elif [[ "$MESSAGE" =~ (doc|readme|comment|example|guide|tutorial) ]] || echo "$FILES_CHANGED" | grep -q "\.md$\|\.txt$\|docs/\|README"; then
                     V_NC_DOCS="$V_NC_DOCS$commit"$'\n'
                   else
                     V_NC_OTHER="$V_NC_OTHER$commit"$'\n'
                   fi
                 done <<< "$V_NON_CONVENTIONAL_COMMITS"
               fi
               
               # Combine conventional and non-conventional commits for this version
               V_ALL_FEATURES="$V_CONVENTIONAL_FEATURES$V_NC_FEATURES"
               V_ALL_FIXES="$V_CONVENTIONAL_FIXES$V_NC_FIXES"
               V_ALL_BREAKING="$V_CONVENTIONAL_BREAKING$V_NC_BREAKING"
               V_ALL_DOCS="$V_CONVENTIONAL_DOCS$V_NC_DOCS"
               
               # Write features section for this version
               if [ -n "$V_ALL_FEATURES" ]; then
                 echo "### üöÄ Added" >> changelog.md
                 echo "$V_ALL_FEATURES" | while read commit; do
                   if [ -n "$commit" ]; then
                     HASH=$(echo $commit | cut -d' ' -f1)
                     MESSAGE=$(echo $commit | cut -d' ' -f2-)
                     echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                   fi
                 done
                 echo "" >> changelog.md
               fi
               
               # Write fixes section for this version
               if [ -n "$V_ALL_FIXES" ]; then
                 echo "### üêõ Fixed" >> changelog.md
                 echo "$V_ALL_FIXES" | while read commit; do
                   if [ -n "$commit" ]; then
                     HASH=$(echo $commit | cut -d' ' -f1)
                     MESSAGE=$(echo $commit | cut -d' ' -f2-)
                     echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                   fi
                 done
                 echo "" >> changelog.md
               fi
               
               # Write breaking changes section for this version
               if [ -n "$V_ALL_BREAKING" ]; then
                 echo "### üí• Changed" >> changelog.md
                 echo "$V_ALL_BREAKING" | while read commit; do
                   if [ -n "$commit" ]; then
                     HASH=$(echo $commit | cut -d' ' -f1)
                     MESSAGE=$(echo $commit | cut -d' ' -f2-)
                     echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                   fi
                 done
                 echo "" >> changelog.md
               fi
               
               # Write documentation section for this version
               if [ -n "$V_ALL_DOCS" ]; then
                 echo "### üìö Documentation" >> changelog.md
                 echo "$V_ALL_DOCS" | while read commit; do
                   if [ -n "$commit" ]; then
                     HASH=$(echo $commit | cut -d' ' -f1)
                     MESSAGE=$(echo $commit | cut -d' ' -f2-)
                     echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                   fi
                 done
                 echo "" >> changelog.md
               fi
               
               # Write other changes section for this version
               if [ -n "$V_NC_OTHER" ]; then
                 echo "### üîß Other Changes" >> changelog.md
                 echo "$V_NC_OTHER" | while read commit; do
                   if [ -n "$commit" ]; then
                     HASH=$(echo $commit | cut -d' ' -f1)
                     MESSAGE=$(echo $commit | cut -d' ' -f2-)
                     echo "- **$MESSAGE** ([$HASH](https://github.com/[USERNAME]/[REPO]/commit/$HASH))" >> changelog.md
                   fi
                 done
                 echo "" >> changelog.md
               fi
             else
               echo "No changes in this version." >> changelog.md
             fi
             
             echo "" >> changelog.md
             echo "---" >> changelog.md
             echo "" >> changelog.md
           done
           
           # Add version comparison links
           echo "## Version Links" >> changelog.md
           echo "" >> changelog.md
           
           LATEST_TAG_FOR_LINKS=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
           if [ -n "$LATEST_TAG_FOR_LINKS" ]; then
             echo "[Unreleased]: https://github.com/[USERNAME]/[REPO]/compare/$LATEST_TAG_FOR_LINKS...HEAD" >> changelog.md
           fi
           
           for tag in $ALL_TAGS; do
             PREV_TAG_FOR_LINKS=$(git describe --tags --abbrev=0 $tag^ 2>/dev/null || echo "")
             if [ -n "$PREV_TAG_FOR_LINKS" ]; then
               echo "[$tag]: https://github.com/[USERNAME]/[REPO]/compare/$PREV_TAG_FOR_LINKS...$tag" >> changelog.md
             else
               echo "[$tag]: https://github.com/[USERNAME]/[REPO]/releases/tag/$tag" >> changelog.md
             fi
           done
           
           echo "‚úÖ Changelog generated successfully at ./changelog.md"
           ```
         fi
      8. **Offer Version Bump Update** üîÑ
         ```bash
         echo ""
         echo "üîÑ Would you like me to automatically update the version in package.json?"
         echo "Current version: $CURRENT_VERSION"
         
         # Calculate new version based on user choice
         if [ "$VERSION_BUMP" == "major" ]; then
           NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1+1 ".0.0"}')
         elif [ "$VERSION_BUMP" == "minor" ]; then
           NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1 "." $2+1 ".0"}')
         elif [ "$VERSION_BUMP" == "patch" ]; then
           NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1 "." $2 "." $3+1}')
         elif [ "$VERSION_BUMP" == "custom" ]; then
           NEW_VERSION="$CUSTOM_VERSION"
         fi
         
         echo "New version would be: $NEW_VERSION"
         read -p "Update package.json version? (y/N): " UPDATE_VERSION
         
         if [[ "$UPDATE_VERSION" =~ ^[Yy]$ ]]; then
           echo "üîÑ Updating package.json version..."
           
           # Update package.json version using npm
           if [ "$VERSION_BUMP" == "custom" ]; then
             # For custom version, we need to manually update
             node -e "
               const fs = require('fs');
               const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
               pkg.version = '$NEW_VERSION';
               fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
               console.log('‚úÖ Updated package.json version to $NEW_VERSION');
             "
           else
             # Use npm version for standard bumps
             npm version $VERSION_BUMP --no-git-tag
             echo "‚úÖ Updated package.json version to $NEW_VERSION"
           fi
           
           # Offer to commit the version change
           echo ""
           echo "üîÑ Would you like me to commit the version change?"
           read -p "Commit version bump? (y/N): " COMMIT_VERSION
           
           if [[ "$COMMIT_VERSION" =~ ^[Yy]$ ]]; then
             echo "üîÑ Committing version change..."
             git add package.json
             git commit -m "chore: bump version to $NEW_VERSION"
             echo "‚úÖ Version change committed successfully"
             
             # Offer to push the commit
             echo ""
             echo "üîÑ Would you like me to push the version commit?"
             read -p "Push version commit? (y/N): " PUSH_VERSION
             
             if [[ "$PUSH_VERSION" =~ ^[Yy]$ ]]; then
               echo "üîÑ Pushing version commit..."
               git push origin $CURRENT_BRANCH
               echo "‚úÖ Version commit pushed successfully"
             fi
           fi
         else
           echo "‚è≠Ô∏è Skipping version update"
         fi
         ```
      9.  **Offer Git Tag Creation** üè∑Ô∏è
         ```bash

         echo "üè∑Ô∏è Would you like me to create a git tag for version $NEW_VERSION?"
         echo "This will create a tag that marks this exact point in your release."
         
         read -p "Create git tag v$NEW_VERSION? (y/N): " CREATE_TAG
         
         if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
           echo "üîÑ Creating git tag v$NEW_VERSION..."
           
           # Check if tag already exists
           if git tag -l "v$NEW_VERSION" | grep -q "v$NEW_VERSION"; then
             echo "‚ùå ERROR: Git tag v$NEW_VERSION already exists!"
             echo ""
             echo "Existing tag details:"
             git show --no-patch --format="%H%n%an%n%ad%n%s" "v$NEW_VERSION" 2>/dev/null || echo "Tag exists but details unavailable"
             echo ""
             echo "Options:"
             echo "1. Use a different version number"
             echo "2. Delete the existing tag (if you're sure it's safe)"
             echo "3. Skip tag creation and create it manually later"
             echo ""
             read -p "Choose option (1-3): " TAG_CONFLICT_CHOICE
             
             case $TAG_CONFLICT_CHOICE in
               1)
                 echo "Please restart the release workflow with a different version number"
                 echo "‚ùå Release workflow terminated due to tag conflict"
                 exit 1
                 ;;
               2)
                 echo "‚ö†Ô∏è WARNING: You're about to delete an existing tag!"
                 echo "This action cannot be undone and may affect other developers."
                 read -p "Are you absolutely sure? Type 'DELETE' to confirm: " DELETE_CONFIRM
                 
                 if [[ "$DELETE_CONFIRM" == "DELETE" ]]; then
                   echo "üîÑ Deleting existing tag v$NEW_VERSION..."
                   git tag -d "v$NEW_VERSION"
                   
                   # Also delete from remote if it exists there
                   if git ls-remote --tags origin "v$NEW_VERSION" | grep -q "v$NEW_VERSION"; then
                     echo "üîÑ Deleting remote tag v$NEW_VERSION..."
                     git push origin ":refs/tags/v$NEW_VERSION"
                   fi
                   
                   echo "‚úÖ Existing tag deleted successfully"
                 else
                   echo "‚ùå Tag deletion cancelled. Release workflow terminated"
                   exit 1
                 fi
                 ;;
               3)
                 echo "‚è≠Ô∏è Skipping tag creation due to conflict"
                 CREATE_TAG=""
                 ;;
               *)
                 echo "‚ùå Invalid choice. Release workflow terminated"
                 exit 1
                 ;;
             esac
           fi
           
           # Create the git tag (only if we didn't skip due to conflict)
           if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
             git tag v$NEW_VERSION
             echo "‚úÖ Git tag v$NEW_VERSION created successfully"
             
             # Offer to push the tag
             echo ""
             echo "üîÑ Would you like me to push the git tag to the remote repository?"
             echo "This makes the tag available to other developers and CI/CD systems."
             
             read -p "Push git tag v$NEW_VERSION? (y/N): " PUSH_TAG
             
             if [[ "$PUSH_TAG" =~ ^[Yy]$ ]]; then
               echo "üîÑ Pushing git tag v$NEW_VERSION..."
               
               # Check for remote tag conflicts before pushing
               if git ls-remote --tags origin "v$NEW_VERSION" | grep -q "v$NEW_VERSION"; then
                 echo "‚ùå ERROR: Remote tag v$NEW_VERSION already exists!"
                 echo "The local tag was created, but cannot be pushed due to remote conflict."
                 echo ""
                 echo "Options:"
                 echo "1. Delete the remote tag first (requires appropriate permissions)"
                 echo "2. Keep the local tag only"
                 echo "3. Delete the local tag and skip"
                 echo ""
                 read -p "Choose option (1-3): " REMOTE_CONFLICT_CHOICE
                 
                 case $REMOTE_CONFLICT_CHOICE in
                   1)
                     echo "üîÑ Deleting remote tag v$NEW_VERSION..."
                     git push origin ":refs/tags/v$NEW_VERSION"
                     echo "üîÑ Now pushing local tag..."
                     git push origin v$NEW_VERSION
                     echo "‚úÖ Git tag v$NEW_VERSION pushed successfully"
                     ;;
                   2)
                     echo "‚è≠Ô∏è Keeping local tag only. You can push it later with: git push origin v$NEW_VERSION"
                     ;;
                   3)
                     echo "üîÑ Deleting local tag..."
                     git tag -d "v$NEW_VERSION"
                     echo "‚è≠Ô∏è Tag creation cancelled"
                     ;;
                   *)
                     echo "‚ùå Invalid choice. Keeping local tag only"
                     ;;
                 esac
               else
                 git push origin v$NEW_VERSION
                 echo "‚úÖ Git tag v$NEW_VERSION pushed successfully"
                 
                 echo ""
                 echo "üéâ Release tag is now live!"
                 echo "Tag URL: https://github.com/[USERNAME]/[REPO]/releases/tag/v$NEW_VERSION"
               fi
             else
               echo "‚è≠Ô∏è Tag created locally but not pushed"
               echo "You can push it later with: git push origin v$NEW_VERSION"
             fi
           fi
         else
           echo "‚è≠Ô∏è Skipping git tag creation"
           echo "You can create the tag manually later with: git tag v$NEW_VERSION"
         fi
         ```
      10. **Final Release Instructions** üìã
         ```bash
         echo ""
         echo "üéâ Release preparation complete!"
         echo ""
         echo "üìã Next steps:"
         echo "1. Review the generated release notes"
         echo "2. Review the updated changelog.md"
         if [[ "$UPDATE_VERSION" =~ ^[Yy]$ ]]; then
           echo "3. ‚úÖ Package.json version updated to $NEW_VERSION"
         else
           echo "3. Update package.json version manually if needed"
         fi
         if [[ "$COMMIT_VERSION" =~ ^[Yy]$ ]]; then
           echo "4. ‚úÖ Version change committed"
         else
           echo "4. Commit version changes manually if needed"
         fi
         if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
           echo "5. ‚úÖ Git tag v$NEW_VERSION created"
         else
           echo "5. Create git tag manually: git tag v$NEW_VERSION"
         fi
         if [[ "$PUSH_TAG" =~ ^[Yy]$ ]]; then
           echo "6. ‚úÖ Git tag pushed to remote"
         else
           echo "6. Push tag manually: git push origin v$NEW_VERSION"
         fi
         echo "7. Create a PR against main with your feature branch"
         echo "Once the PR is merged, the publishing Github Actions workflow will be triggered."
         echo ""
         echo ""
         echo "üìÅ Generated files:"
         echo "- Release notes: RELEASE_NOTES_v$CURRENT_VERSION_to_v$NEW_VERSION.md"
         echo "- Changelog: changelog.md"
         if [[ "$UPDATE_VERSION" =~ ^[Yy]$ ]]; then
           echo "- Updated: package.json (version: $NEW_VERSION)"
         fi
         if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
           echo "- Git tag: v$NEW_VERSION"
         fi
         echo ""
         echo "üîó Useful links:"
         if [[ "$PUSH_TAG" =~ ^[Yy]$ ]]; then
           echo "- Release tag: https://github.com/[USERNAME]/[REPO]/releases/tag/v$NEW_VERSION"
           echo "- Compare changes: https://github.com/[USERNAME]/[REPO]/compare/$LATEST_TAG...v$NEW_VERSION"
         fi
         echo "- Changelog: ./changelog.md"
         echo ""
         echo "üéØ Release workflow summary:"
         echo "- Branch: $CURRENT_BRANCH"
         echo "- Version bump: $CURRENT_VERSION ‚Üí $NEW_VERSION ($VERSION_BUMP)"
         echo "- Changes analyzed: $(echo "$COMMITS" | wc -l | tr -d ' ') commits"
         echo "- Breaking changes: $BREAKING_COUNT"
         echo "- New features: $FEAT_COUNT"
         echo "- Bug fixes: $FIX_COUNT"
         ```

examples:
  - input: |
      User: "Create a release with minor version bump"
      Current branch: feat/new-feature
      Git analysis: 3 feat commits, 1 fix commit, 2 docs commits
      Current version: 1.2.3
    output: |
      ## üöÄ Release Workflow Process
      
      I'll help you create comprehensive release notes, update the changelog, and handle version bumping! Let me analyze your changes and guide you through the entire release process.
      
      1. **Branch Validation** ‚úÖ
         Current branch: feat/new-feature
         ‚úÖ Not on main branch - proceeding with release notes generation
      
      2. **Identify Current Version**:
         Current package.json version: 1.2.3
         Latest git tag: v1.2.3
      
      3. **Check User Request for Version Bump**:
         User requested minor version bump
      
      4. **Analyze Changes for Guidance**:
         Analysis suggests: minor (3 new features, 1 bug fix, 2 documentation updates)
         ‚úÖ User choice matches analysis
      
      5. **Generate Structured Release Notes**:
         # What's Changed in [PACKAGE_NAME] v1.3.0
         
         **Release Date**: 2024-01-15
         **Previous Version**: 1.2.3
         **Version Bump**: MINOR - New features added
         **Branch**: feat/new-feature
         
         ## üöÄ New Features
         - **Add user authentication system** ([a1b2c3d](https://github.com/user/repo/commit/a1b2c3d)) - Implemented JWT-based authentication
         - **Add dark mode support** ([e4f5g6h](https://github.com/user/repo/commit/e4f5g6h)) - Added theme switching functionality
         - **Add search functionality** ([i7j8k9l](https://github.com/user/repo/commit/i7j8k9l)) - Implemented global search with filters
         
         ## üêõ Bug Fixes  
         - **Fix memory leak in data processing** ([m1n2o3p](https://github.com/user/repo/commit/m1n2o3p)) - Resolved issue with large dataset handling
         
         ## üìö Documentation
         - **Update API documentation** ([q4r5s6t](https://github.com/user/repo/commit/q4r5s6t)) - Added comprehensive API examples
         - **Update README with setup instructions** ([u7v8w9x](https://github.com/user/repo/commit/u7v8w9x)) - Improved installation guide
      
      6. **Generate Changelog** üìù
         üîÑ Now generating comprehensive changelog...
         ‚úÖ Changelog generated successfully at ./changelog.md
      
      7. **Offer Version Bump Update** üîÑ
         üîÑ Would you like me to automatically update the version in package.json?
         Current version: 1.2.3
         New version would be: 1.3.0
         Update package.json version? (y/N): y
         ‚úÖ Updated package.json version to 1.3.0
         
         üîÑ Would you like me to commit the version change?
         Commit version bump? (y/N): y
         ‚úÖ Version change committed successfully
         
         üîÑ Would you like me to push the version commit?
         Push version commit? (y/N): y
         ‚úÖ Version commit pushed successfully

  - input: |
      User: "Create a release"
      Current branch: wip/experimental-feature
      Git analysis: 2 feat commits, 1 fix commit
      Current version: 1.0.0
    output: |
      ## üöÄ Release Workflow Process
      
      I'll help you create comprehensive release notes, update the changelog, and handle version bumping! Let me analyze your changes and guide you through the entire release process.
      
      1. **Branch Validation** ‚úÖ
         Current branch: wip/experimental-feature
         ‚úÖ Not on main branch - proceeding with release notes generation
         
         üîç Validating branch naming conventions...
         ‚ùå ERROR: Releases can only be created from branches that start with 'release/', 'hotfix/', or 'fix/'
         
         Current branch: wip/experimental-feature
         
         Please create a release branch first:
         git checkout -b release/v[VERSION]
         
         Examples of valid release branches:
         - release/v1.2.3
         - release/v2.0.0
         - hotfix/security-patch-v1.2.4
         - fix/memory-leak-v1.1.5
         - release/feature-name-v1.1.0
         
         ‚ùå Release workflow terminated due to invalid branch

  - input: "Make a release" (on wip/experimental branch)
    output: "Should detect invalid branch pattern, show error message requiring 'release/', 'hotfix/', or 'fix/' prefix, and terminate workflow"
  
  - input: "Create release" (on custom-named branch without standard patterns)
    output: "Should detect invalid branch pattern, show error message requiring 'release/', 'hotfix/', or 'fix/' prefix, and terminate workflow"
  
  - input: "Create release" (on feature/new-feature branch)
    output: "Should detect invalid branch pattern, show error message requiring 'release/', 'hotfix/', or 'fix/' prefix, and terminate workflow"
  
  - input: "Create release" (on hotfix/security-patch-v1.2.4 branch)
    output: "Should validate hotfix branch, proceed with release workflow, and allow version bumping"
  
  - input: "Create release" (on fix/memory-leak-v1.1.5 branch)
    output: "Should validate fix branch, proceed with release workflow, and allow version bumping"

  - input: |
      User: "Create a release"
      Current branch: release/v2.0.0
      Git analysis: 2 feat commits, 1 fix commit, 3 non-conventional commits
      Non-conventional commits: "Add new API endpoint", "Fix broken login", "Update documentation"
      Current version: 1.5.0
    output: |
      ## üöÄ Release Workflow Process
      
      I'll help you create comprehensive release notes, update the changelog, and handle version bumping! Let me analyze your changes and guide you through the entire release process.
      
      1. **Branch Validation** ‚úÖ
         Current branch: release/v2.0.0
         ‚úÖ Branch validation passed - using release/v2.0.0
      
      2. **Identify Current Version**:
         Current package.json version: 1.5.0
         Latest git tag: v1.5.0
      
      3. **Check User Request for Version Bump**:
         No version bump specified by user
      
      4. **Analyze Changes for Guidance**:
         üîç Found non-conventional commits, analyzing content for categorization...
           üìù Non-conventional commit categorized as FEATURE: Add new API endpoint
           üêõ Non-conventional commit categorized as FIX: Fix broken login
           üìö Non-conventional commit categorized as DOCS: Update documentation
         
         üìä Non-conventional commit analysis complete:
           - Features: 1
           - Fixes: 1
           - Breaking: 0
           - Docs: 1
           - Other: 0
         
         üìà Commit analysis summary:
           - Breaking changes: 0
           - New features: 3 (2 conventional + 1 non-conventional)
           - Bug fixes: 2 (1 conventional + 1 non-conventional)
           - Documentation: 1 (0 conventional + 1 non-conventional)
           - Style/Refactor: 0
           - Performance: 0
           - Tests: 0
           - Chores: 0
           - Suggested version bump: minor
         
         Choose your version bump:
         1) Major version: 1.5.0 ‚Üí 2.0.0 (breaking changes)
         2) Minor version: 1.5.0 ‚Üí 1.6.0 (new features)
         3) Patch version: 1.5.0 ‚Üí 1.5.1 (bug fixes)
         4) Custom version
         
         Enter your choice (1-4): 2
      
      5. **Generate Structured Release Notes**:
         # What's Changed in [PACKAGE_NAME] v1.6.0
         
         **Release Date**: 2024-01-15
         **Previous Version**: 1.5.0
         **Version Bump**: MINOR - New features added
         **Branch**: release/v2.0.0
         
         ## üöÄ New Features
         - **Add user authentication system** ([a1b2c3d](https://github.com/user/repo/commit/a1b2c3d)) - Implemented JWT-based authentication
         - **Add dark mode support** ([e4f5g6h](https://github.com/user/repo/commit/e4f5g6h)) - Added theme switching functionality
         - **Add new API endpoint** ([x9y0z1a](https://github.com/user/repo/commit/x9y0z1a)) - New REST API endpoint for data processing
         
         ## üêõ Bug Fixes  
         - **Fix memory leak in data processing** ([m1n2o3p](https://github.com/user/repo/commit/m1n2o3p)) - Resolved issue with large dataset handling
         - **Fix broken login** ([b2c3d4e](https://github.com/user/repo/commit/b2c3d4e)) - Resolved authentication issue
         
         ## üìö Documentation
         - **Update documentation** ([f5g6h7i](https://github.com/user/repo/commit/f5g6h7i)) - Updated API documentation and examples
      
      6. **Generate Changelog** üìù
         üîÑ Now generating comprehensive changelog...
         üîç Categorizing non-conventional commits for changelog...
         ‚úÖ Changelog generated successfully at ./changelog.md